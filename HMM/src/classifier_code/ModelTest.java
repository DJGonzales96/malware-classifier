package classifier_code;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.*;

public class ModelTest {
	int m, n; // M = # of observation symbols, N = # of states
	int T;
	double[][] A;
	double[][] B;
	double[] c;
	double[] pi;
	int maxIters;
	int iters;
	double oldLogProb;

	static final char[] symbols = // aka observations
			{ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
					'v', 'w', 'x', 'y', 'z', ' ' };

	private void initialize(int m, int n) {
		this.m = m;
		this.n = n;

		// A = nxn TRANSITION MTX
		A = new double[n][n];
		Arrays.fill(A, (1.0 / n));

		// B = nxm OBSERVATION MTX
		B = new double[n][m];
		Arrays.fill(B, (1.0 / m));

		// pi = 1xn INITIAL STATE
		pi = new double[n];
		Arrays.fill(pi, (1.0 / n));
	}

	private void printResults() {
		
		// print A
		System.out.println("\n[A] Transition Matrix");
		for (int i = 0; i < A.length; i++) {
			for (int j = 0; j < A[i].length; j++) {
				System.out.printf("%9.10f ", A[i][j]);
			}
			System.out.println();
		}

		// print B
		System.out.println("\n[B] Observation Matrix");
		for (int i = 0; i < B.length; i++) {
			for (int j = 0; j < B[i].length; j++) {
				System.out.printf("%9.10f ", B[i][j]);
			}
			System.out.println();
		}

		// print pi
		System.out.println("\n[pi] Initial States");
		for (int i = 0; i < pi.length; i++)
			System.out.printf("%.3f ", pi[i]);
	}

	public void trainHMM(int[] O) {
		boolean contTraining = true;
		T = O.length; // T = length of obs sequence
		m = 27;
		n = 2;

		maxIters = 100;
		iters = 0;
		oldLogProb = Double.NEGATIVE_INFINITY;

		A = new double[][] { { 0.47468, 0.51656}, { 0.52532, 0.48344 } };

		B = new double[][] 
		{
						{ 0.03735, 0.03404, 0.03455, 0.03828, 0.03782, 0.03922, 0.03688, 0.03408, 0.03875, 0.04062, 
						  0.03735, 0.03968, 0.03548, 0.03735, 0.04062, 0.03595, 0.03641, 0.03408, 0.04062, 0.03548, 
						  0.03922, 0.04062, 0.03455, 0.03595, 0.03408, 0.03408, 0.03688 },
						{ 0.03909, 0.03537, 0.03537, 0.03909, 0.03583, 0.03630, 0.04048, 0.03537, 0.03490, 0.03909, 
					      0.03490, 0.03723, 0.03537, 0.03909, 0.03397, 0.03397, 0.03816, 0.03676, 0.04048, 0.03443, 
					      0.03537, 0.03955, 0.03816, 0.03723, 0.03769, 0.03955, 0.03397 }
		};

		pi = new double[] { 0.51316, 0.48684 };
		c = new double[T];

		while (contTraining) {
			double[][] alpha = alphaPass(O);
			double[][] beta = betaPass(O);
			List<Object> gammas = computeGammas(O, alpha, beta);
			double[][] gamma = (double[][]) gammas.get(0);
			double[][][] digamma = (double[][][]) gammas.get(1);
			re_estimate(O, gamma, digamma);

			// Compute the probability
			double logProb = 0;
			for (int i = 0; i < T; i++)
				logProb = logProb + Math.log(c[i]);
			logProb *= -1;

			iters = iters + 1;
			if (iters < maxIters && logProb > oldLogProb) {
				oldLogProb = logProb;
				System.out.println(logProb);
				// goto alpha pass
			} else {
				System.out.println(oldLogProb);
				contTraining = false; // end loop
				printResults();
			}
		}
	}

	public double[][] alphaPass(int[] O) {
		// alpha pass
		double[][] alpha = new double[T][n];

		c[0] = 0.0;
		for (int i = 0; i < n; i++) {
			alpha[0][i] = pi[i] * B[i][O[0]];
			c[0] = c[0] + alpha[0][i];
		}

		// scale first alpha
		c[0] = 1.0 / c[0];
		for (int i = 0; i < n; i++) {
			alpha[0][i] = c[0] * alpha[0][i];
		}

		// compute alpha
		for (int t = 1; t < T; t++) {
			c[t] = 0.0;
			for (int i = 0; i < n; i++) {
				alpha[t][i] = 0.0;
				for (int j = 0; j < n; j++) {
					alpha[t][i] = alpha[t][i] + alpha[t - 1][j] * A[j][i];
				}
				alpha[t][i] = alpha[t][i] * B[i][O[t]];
				c[t] = c[t] + alpha[t][i];
			}
			// scale all alpha
			c[t] = 1.0 / c[t];
			for (int i = 0; i < n; i++) {
				alpha[t][i] = c[t] * alpha[t][i];
			}
		}

		return alpha;
	}

	public double[][] betaPass(int[] O) {
		// beta pass
		double[][] beta = new double[T][n];

		// scale first beta
		for (int i = 0; i < n; i++) {
			beta[T - 1][i] = c[T - 1];
		}
		// scale all beta
		for (int t = T - 2; t >= 0; t--) {
			for (int i = 0; i < n; i++) {
				beta[t][i] = 0.0;
				for (int j = 0; j < n; j++) {
					beta[t][i] = beta[t][i] + A[i][j] * B[j][O[t + 1]] * beta[t + 1][j];
				}
				beta[t][i] = c[t] * beta[t][i];
			}
		}
		return beta;
	}

	public List<Object> computeGammas(int[] O, double[][] alpha, double[][] beta) {
		// gammas
		double[][] gamma = new double[T][n];
		double[][][] digamma = new double[T][n][n];

		for (int t = 0; t < T - 1; t++) {
			double denom = 0;
			for (int i = 0; i < n; i++) {
				for (int j = 0; j < n; j++) {
					denom = denom + alpha[t][i] * A[i][j] * B[j][O[t + 1]] * beta[t + 1][j];
				}
			}
			for (int i = 0; i < n; i++) {
				gamma[t][i] = 0;
				for (int j = 0; j < n; j++) {
					digamma[t][i][j] = (alpha[t][i] * A[i][j] * B[j][O[t + 1]] * beta[t + 1][j]) / denom;
					gamma[t][i] = gamma[t][i] + digamma[t][i][j];
				}
			}
		}
		double denom = 0;
		for (int i = 0; i < n; i++) {
			denom = denom + alpha[T - 1][i];
		}
		for (int i = 0; i < n; i++) {
			gamma[T - 1][i] = alpha[T - 1][i] / denom;
		}

		return Arrays.asList(gamma, digamma);
	}

	public void re_estimate(int[] O, double[][] gamma, double[][][] digamma) {

		// re-restimate pi
		for (int i = 0; i < n; i++) {
			pi[i] = gamma[0][i];
		}

		// re-estimate A
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				double numer = 0;
				double denom = 0;
				for (int t = 0; t < T - 1; t++) {
					numer = numer + digamma[t][i][j];
					denom = denom + gamma[t][i];
				}
				A[i][j] = numer / denom;
			}
		}

		// re-estimate B
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				double numer = 0;
				double denom = 0;
				for (int t = 0; t < T; t++) { // NOTE: bug in pseudocode here
					if (O[t] == j) {
						numer = numer + gamma[t][i];
					}
					denom = denom + gamma[t][i];
				}
				B[i][j] = numer / denom;
			}
		}
	}

	public static void main(String args[]) {
		int[] observations = new int[50000];
		Scanner in;
		try {
			in = new Scanner(new File("tokenized_corpus.txt"));
			int indx = 0;
			while (in.hasNextLine()) {
				if (indx == observations.length)
					break;

				int token = Integer.parseInt(in.nextLine());
				observations[indx++] = token;
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

		ModelTest marvin = new ModelTest();

		marvin.trainHMM(observations);
	}

}
