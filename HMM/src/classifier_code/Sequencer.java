package classifier_code;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Sequencer {
	Map<String, String> dictionary;

	public Sequencer(int N, File malwareFamily) {
		MalwareParser dictionaryBuilder = new MalwareParser();
		try {
			dictionary = dictionaryBuilder.buildDictionary(N, malwareFamily);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public void processSupportVectorScoringData(File malwareTrainSet, int setSize) throws IOException {		
		File directory = new File(malwareTrainSet.getParent() + "\\" + malwareTrainSet.getParentFile().getName() + "_svm_scores");
		if(!directory.exists())
			directory.mkdir();
		
		File[] files = malwareTrainSet.listFiles();
		int last = files.length - 1;
		for(int i=last; i > last - setSize; i--) {
			File scoreFile = new File(directory.getPath() + "\\score_" + files[i].getName());
			scoreFile.createNewFile();
			FileWriter out = new FileWriter(scoreFile);
			
			Scanner reader = new Scanner(files[i]);
			while (reader.hasNextLine()) {
				String opcode = reader.nextLine();
				String token = dictionary.get(opcode);
				out.write(token + '\n');
				out.flush();
			}
			reader.close();
			out.close();
		}
		
	}
	
	// Needs to produce 3 training files for use by SVM
	// NEEDS TRAINING_SET_SIZE * numTrainingFiles + SCORING_SET_SIZE amount of files
	public void processSupportVectorTrainingData(File malwareTrainSet, int numTrainingFiles) throws IOException {
		final int TRAINING_SET_SIZE = 100;
		final int SCORING_SET_SIZE = 10;
		System.out.println("\tFile: " + malwareTrainSet.toString() + "...");
		
		File[] files = malwareTrainSet.listFiles();
		int indx = 0;
		for(int i=0; i<numTrainingFiles; i++) {
			String filename =  malwareTrainSet + "_svm" + i + ".txt";
			File tokenizedOpcodes = new File(filename);
			tokenizedOpcodes.createNewFile();
			FileWriter out = new FileWriter(tokenizedOpcodes);
			
			int limit = indx + TRAINING_SET_SIZE;
			for (int j =indx; indx < limit; indx++) {
				Scanner reader = new Scanner(files[j]);
				while (reader.hasNextLine()) {
					String opcode = reader.nextLine();
					String token = dictionary.get(opcode);
					out.write(token + '\n');
					out.flush();
				}
				reader.close();
			}
			out.close();
			}
		
		processSupportVectorScoringData(malwareTrainSet, SCORING_SET_SIZE);
		System.out.println("\tDone.");
		}
	
	public void processData(File malwareFamily) throws IOException {
		System.out.println("\tFile: " + malwareFamily.toString() + "...");

		File[] datasets = malwareFamily.listFiles();
		if (datasets != null) {
			for (File set : datasets) {

				String filename = set.toString() + "_data.txt";
				File tokenizedOpcodes = new File(filename);
				tokenizedOpcodes.createNewFile();
				FileWriter out = new FileWriter(tokenizedOpcodes);

				File[] files = set.listFiles();
				if (files != null) {
					for (File file : files) {
						Scanner reader = new Scanner(file);
						while (reader.hasNextLine()) {
							String opcode = reader.nextLine();
							String token = dictionary.get(opcode);
							out.write(token + '\n');
							out.flush();
						}
						reader.close();
					}
					out.close();
				}
			}
		}
		System.out.println("\tDone.");
	}

	public char[] getSequenceFromFile(File malware) throws FileNotFoundException {
		ArrayList<Character> sequenceList = new ArrayList<>();

		Scanner reader = new Scanner(malware);
		int count = 0;
		while (reader.hasNextLine()) {
			String opcode = reader.nextLine();
			Character token = dictionary.get(opcode).charAt(0);
			sequenceList.add(token);
			count++;
		}
		reader.close();
		
		char[] sequence = new char[count];
		for(int i=0; i<count; i++)
			sequence[i] = sequenceList.get(i);
		
		return sequence;
	}
	
	public char[] getSequenceFromFile(int N, File malware) throws FileNotFoundException {
		char[] sequence = new char[N];

		Scanner reader = new Scanner(malware);
		int count = 0;
		while (reader.hasNextLine()) {
			
			if(count == N)
				break;
			
			String opcode = reader.nextLine();
			char token = dictionary.get(opcode).charAt(0);
			sequence[count] = token;
			count++;
		}
		reader.close();
		return sequence;
	}
	
	public int[] getTrainingSequence(double T, File trainData) throws FileNotFoundException {
		int[] sequence = new int[(int) T];
		
		Scanner reader = new Scanner(trainData);
		int count = 0;
		while(reader.hasNextLine()) {
			if(count == T)
				break;
			
			String encodedValue = reader.nextLine();
			try {
			sequence[count++] = Integer.parseInt(encodedValue);}
			catch(NumberFormatException ex) {
				//BUG: null values in training data???
			}
		}
		
		return sequence;
	}
	
	public int[] getTestingSequence(double T, File testData) throws FileNotFoundException {
		int[] sequence = new int[(int) T];
		
		Scanner reader = new Scanner(testData);
		int count = 0;
		while(reader.hasNextLine()) {
			if(count == T)
				break;
			
			String encodedValue = dictionary.get(reader.nextLine());
			if(encodedValue != null)
				sequence[count++] = (Integer.parseInt(encodedValue));
		}
		
		return sequence;
	}
	
	// Dead code?
	public int[] toInt(String[] seq) {
		Map<String, Integer> sequenceToInt = new HashMap<>();
		int intValue = 0;
		for(String oldKey : dictionary.keySet()) {
			sequenceToInt.put(oldKey, intValue++);
		}
		
		int[] numSeq = new int[seq.length];
		for(int i = 0; i<seq.length; i++)
			numSeq[i] = sequenceToInt.get(seq[i]);
		
		return numSeq;
	}

}
