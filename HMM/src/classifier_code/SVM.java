package classifier_code;
import libsvm.*;

public class SVM {
	
	// N-Dimensional vector, scores.length = N
	public static svm_node[] buildVector(double[] scores) {
	    svm_node[] point = new svm_node[scores.length];
	    
	    // Normalize scores
	    int sum=0;
	    for(int i=0; i<scores.length; i++)
	    	sum += scores[i];
	    
	    for(int i=0; i<scores.length; i++) {
	    	point[i] = new svm_node();
	    	point[i].index = i+1;
	    	point[i].value = scores[i]/sum;
	    }

	    return point;
	}
	
	private static double[] prepareY(int size) {
	    double[] y = new double[size];

	    for (int i=0; i < size; i++)
	        y[i] = 1;

	    return y;
	}
	
	public static svm_model buildModel(svm_node[][] nodes) {
	    svm_parameter param = new svm_parameter();
	    param.svm_type    = svm_parameter.ONE_CLASS;
	    param.kernel_type = svm_parameter.RBF;
	    param.gamma       = 0.1;
	    param.nu          = 0.5;

	 
	    svm_problem problem = new svm_problem();
	    problem.x = nodes;
	    problem.l = nodes.length;
	    problem.y = prepareY(nodes.length);


	    return svm.svm_train(problem, param);
	}

	
	public static double predict(svm_model model, svm_node[] nodes) {
	    double[] values = new double[2];
	    double result = svm.svm_predict_values(model, nodes, values);

	    return values[0];
	}
	
}
