package classifier_code;

import java.util.*;

public class Model {
	int m, n; // M = # of observation symbols, N = # of states
	int T;
	double[][] A;
	double[][] B;
	double[] c;
	double[] pi;
	int maxIters;
	int iters;
	double oldLogProb;

	double[][] alpha;
	double[][] beta;
	double[][] gamma;
	double[][][] digamma;

	static final char[] symbols = // aka observations
			{ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
					'v', 'w', 'x', 'y', 'z', ' ' };

	private void initialize(int m, int n) {
		this.m = m;
		this.n = n;

		// A = nxn TRANSITION MTX
		A = new double[n][n];
		for (int i = 0; i < n; i++) {
			double denom = getRandomNumber(((double) n - 0.1), ((double) n + 0.1));
			Arrays.fill(A[i], (1.0 / denom));
		}

		// B = nxm OBSERVATION MTX
		B = new double[n][m];
		for (int i = 0; i < n; i++) {
			double denom = getRandomNumber(((double) m - 0.1), ((double) m + 0.1));
			Arrays.fill(B[i], (1.0 / denom));
		}

		// pi = 1xn INITIAL STATE
		pi = new double[n];
		double denom = getRandomNumber(((double) n - 0.1), ((double) n + 0.1));
		Arrays.fill(pi, (1.0 / denom));

		// c = 1xT CONSTANTS
		c = new double[T];

		alpha = new double[T][n];
		beta = new double[T][n];
		gamma = new double[T][n];
		digamma = new double[T][n][n];
	}
	
	private double[][] normalize(double[][] a) {
		for (int i = 0; i < a.length; i++) {
			double rowDenom = 0.0;
			for (int j = 0; j < a[i].length; j++) {
				rowDenom += a[i][j];
			}
			for(int j2 = 0; j2 < a[i].length; j2++) {
				a[i][j2] = a[i][j2] / rowDenom;
			}
		}
		return a;
	}
	
	public double[] normalize(double[] a) {
		double rowDenom = 0.0;
		for (int i = 0; i < a.length; i++) {
			rowDenom+= a[i];
		}
		for (int i = 0; i < a.length; i++) {
			a[i] =  a[i] / rowDenom;
		}
		return a;
	}

	private void newInitialize(int m, int n) {
		A = new double[n][n];
		for (int i = 0; i < A.length; i++) {
			for (int j = 0; j < A[i].length; j++) {
				double denom = getRandomNumber(((double) n - 1.0), ((double) n + 1.0));
				A[i][j] = 1.0 / denom;
			}
		}
		A = normalize(A);

		B = new double[n][m];
		for (int i = 0; i < B.length; i++) {
			for (int j = 0; j < B[i].length; j++) {
				double denom = getRandomNumber(((double) m - 1.0), ((double) m + 1.0));
				B[i][j] = 1.0 / denom;
			}
		}
		B = normalize(B);
		
		pi = new double[n];
		for (int i = 0; i < pi.length; i++) {
			double denom = getRandomNumber(((double) n - 1.0), ((double) n + 1.0));
			pi[i] = 1.0 / denom;
			}
		pi = normalize(pi);
		
		// c = 1xT CONSTANTS
		c = new double[T];

		alpha = new double[T][n];
		beta = new double[T][n];
		gamma = new double[T][n];
		digamma = new double[T][n][n];
	}
	

	private void printResults() {

		// print A
		System.out.println("\n[A] Transition Matrix");
		for (int i = 0; i < A.length; i++) {
			for (int j = 0; j < A[i].length; j++) {
				System.out.printf("%9.10f ", A[i][j]);
			}
			System.out.println();
		}

		// print B
		System.out.println("\n[B] Observation Matrix");
		for (int i = 0; i < B.length; i++) {
			for (int j = 0; j < B[i].length; j++) {
				System.out.printf("%9.10f ", B[i][j]);
			}
			System.out.println();
		}

		// print pi
		System.out.println("\n[pi] Initial States");
		for (int i = 0; i < pi.length; i++)
			System.out.printf("%.3f ", pi[i]);
	}

	public void trainHMM(int[] O, int m, int n) {
		boolean contTraining = true;
		T = O.length; // T = length of obs sequence
		this.m = m;
		this.n = n;

		maxIters = 10;
		iters = 0;
		oldLogProb = Double.NEGATIVE_INFINITY;

		newInitialize(m, n);

		while (contTraining) {
			alphaPass(O);
			betaPass(O);
			computeGammas(O);
			re_estimate(O);

			// Compute the probability
			double logProb = 0;
			for (int i = 0; i < T; i++)
				logProb = logProb + Math.log(c[i]);
			logProb *= -1;

			iters = iters + 1;
			if (iters < maxIters && logProb > oldLogProb) {
				oldLogProb = logProb;
				//System.out.println("Iter: " + iters + "\n"); DEBUG
				//printResults(); DEBUG
				// goto alpha pass
			} else {
				// System.out.println(oldLogProb); DEBUG
				contTraining = false; // end loop
				// printResults(); DEBUG
			}
		}
	}

	public void alphaPass(int[] O) {
		// alpha pass
		// double[][] alpha = new double[T][n];

		c[0] = 0.0;
		for (int i = 0; i < n; i++) {
			alpha[0][i] = pi[i] * B[i][O[0]];
			c[0] = c[0] + alpha[0][i];
		}

		// scale first alpha
		c[0] = 1.0 / c[0];
		for (int i = 0; i < n; i++) {
			alpha[0][i] = c[0] * alpha[0][i];
		}

		// compute alpha
		for (int t = 1; t < T; t++) {
			c[t] = 0.0;
			for (int i = 0; i < n; i++) {
				alpha[t][i] = 0.0;
				for (int j = 0; j < n; j++) {
					alpha[t][i] = alpha[t][i] + alpha[t - 1][j] * A[j][i];
				}
				alpha[t][i] = alpha[t][i] * B[i][O[t]];
				c[t] = c[t] + alpha[t][i];
			}
			// scale all alpha
			c[t] = 1.0 / c[t];
			for (int i = 0; i < n; i++) {
				alpha[t][i] = c[t] * alpha[t][i];
			}
		}

	}

	public void betaPass(int[] O) {
		// beta pass
		// double[][] beta = new double[T][n];

		// scale first beta
		for (int i = 0; i < n; i++) {
			beta[T - 1][i] = c[T - 1];
		}
		// scale all beta
		for (int t = T - 2; t >= 0; t--) {
			for (int i = 0; i < n; i++) {
				beta[t][i] = 0.0;
				for (int j = 0; j < n; j++) {
					beta[t][i] = beta[t][i] + A[i][j] * B[j][O[t + 1]] * beta[t + 1][j];
				}
				beta[t][i] = c[t] * beta[t][i];
			}
		}
	}

	public void computeGammas(int[] O) {
		// gammas
		// double[][] gamma = new double[T][n];
		// double[][][] digamma = new double[T][n][n];

		for (int t = 0; t < T - 1; t++) {
			double denom = 0;
			for (int i = 0; i < n; i++) {
				for (int j = 0; j < n; j++) {
					denom = denom + alpha[t][i] * A[i][j] * B[j][O[t + 1]] * beta[t + 1][j];
				}
			}
			for (int i = 0; i < n; i++) {
				gamma[t][i] = 0;
				for (int j = 0; j < n; j++) {
					digamma[t][i][j] = (alpha[t][i] * A[i][j] * B[j][O[t + 1]] * beta[t + 1][j]) / denom;
					gamma[t][i] = gamma[t][i] + digamma[t][i][j];
				}
			}
		}
		double denom = 0;
		for (int i = 0; i < n; i++) {
			denom = denom + alpha[T - 1][i];
		}
		for (int i = 0; i < n; i++) {
			gamma[T - 1][i] = alpha[T - 1][i] / denom;
		}

	}

	public void re_estimate(int[] O) {

		// re-restimate pi
		for (int i = 0; i < n; i++) {
			pi[i] = gamma[0][i];
		}

		// re-estimate A
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				double numer = 0;
				double denom = 0;
				for (int t = 0; t < T - 1; t++) {
					numer = numer + digamma[t][i][j];
					denom = denom + gamma[t][i];
				}
				A[i][j] = numer / denom;
			}
		}

		// re-estimate B
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				double numer = 0;
				double denom = 0;
				for (int t = 0; t < T; t++) { // NOTE: bug in pseudocode here
					if (O[t] == j) {
						numer = numer + gamma[t][i];
					}
					denom = denom + gamma[t][i];
				}
				B[i][j] = numer / denom;
			}
		}
	}

	public double computeProbability() {
		double logProb = 0;
		for (int i = 0; i < T; i++) {
			if(!Double.isInfinite(c[i]) && !Double.isNaN(c[i]))
				logProb = logProb + Math.log(c[i]);
			}
		logProb *= -1;

		return logProb;
	}

	public double score(int[] O) {
		maxIters = 100;
		iters = 0;
		oldLogProb = Double.NEGATIVE_INFINITY;
		//boolean cont = true;

		// Set the constant c[] array values to compute probability
		//while (cont) {
			alphaPass(O);
			double logProb = computeProbability();
			return logProb;
			//iters = iters + 1;
			//if (iters < maxIters) {
			//	oldLogProb = logProb;
			//} else
			//	cont = false;
		//}

		//return oldLogProb;
	}

	public double getRandomNumber(double min, double max) {
		return ((Math.random() * (max - min)) + min);
	}

}
